// директивы подключения заголовочных файлов
#include "stdio.h" // поиск файла в текущей директории
#include <malloc.h> // поиск файла в системных директориях
#include <string.h>

// определение структуры
typedef struct
{
	char* name; // указатель(для динамического объекта). Перед использованием, нужно оттдельно выделить память в куче
	int sex; // стековый объект
	int age; // стековый объект
	char phone[15]; // стековый объект для хранения строки длинной до 14 символов + нулевой байт
} Record;

// объявление(declaration) прототипов функций (сигнатура вызова с последовательностью типов параметров)
void PrintRecord(const Record*); // объявление типов параметров
void PrintFileRecord(FILE*, const Record*);
int ScanFileRecord(FILE*, Record*);
void ReplaceStr(const char* source, char* destination, const char oldChar, const char newChar);

int main() // основная функция, которая вызывается при запуске исполняемого файла (точка входа)
{// начало тела основной функции
	// объявление переменной c типом данных, структура "Record"
	Record item;
	char* myName = "John Blood";
	char* myPhone = "+7(921)1231234";

	// выделение памяти для массива символов, указателю присваивается адрес начала выделенной области памяти
	item.name = (char*)malloc((strlen(myName) + 1) * sizeof(char));
	// берем длинну строки "John", добавляем 1 (для нулевого байта в конце строки) 
	// и умножаем ее на размер одного символа в памяти
	// получаем указатель на выделенную память типа (void*) и приводим его к строковому типу (char*)

	//проверяем, выделенна ли память? Если нет, то завершаем выполнение программы
	if (item.name == NULL) return -1;

	// копирование байтов в выделенный участок памяти
	strcpy(item.name, myName); // мы передаем в функцию, в качестве аргумента, поле "name" переменной "item"
	strcpy(item.phone, myPhone); // инициализация второй строки

	// инициализация полей переменной(структуры)
	item.sex = 1; // присваиваем значение и тем самым инициализируем поле "sex" переменной "item"
	item.age = 33;
	// необходимо, чтобы все переменные были определены (это именно определение - отличается от объявления тем, что вm этот момент под объект выделяется память)

	FILE* pFile; // объявление переменной, для хранения указателя на файл
	pFile = fopen("myfile.txt", "a"); // открываем файл в режиме записи в конец существующего файла

	if (pFile != NULL) // указатель не равен нулю, если файл удалось открыть
	{
		PrintFileRecord(pFile, &item); // вызов функции печати в файл
		fclose(pFile); // закрытие файла
	}

	pFile = fopen("myfile.txt", "r"); // открываем файл в режиме чтения
	if (pFile != NULL) // указатель не равен нулю, если файл удалось открыть
	{
		while (ScanFileRecord(pFile, &item) != EOF) // чтение из файла, пока читается
		{
			// выводим каждую запись на консоль
			PrintRecord(&item);
		}
		fclose(pFile);
	}

	getchar(); // ждем ввода, чтобы консоль не закрывалась

	free(item.name);// освобождаем выделенную в куче(heap) память

	return 0;
}// завершение тела основной функции


// определение(definition) функции, в отличие от объявления содержит еще и тело функции {...}
void PrintRecord(const Record *itemPrint) // параметр itemPrint - это принятый функцией аргумент (item)
{
	// выводим данные на консоль
	printf("%s %d %d %s\n", itemPrint->name, itemPrint->age, itemPrint->sex, itemPrint->phone);
	// item - указатель на структуру, поэтому в качестве оператора доступа к членам класса(структуры) мы используем "->" (доступ через указатель на структуру/объект)
}

// функция ничего не возвращает, поэтому возврщаемый тип void
void PrintFileRecord(FILE* pFile, const Record* itemPrint)
{
	//выделяем память для модифицированных строк
	char* name = (char*)malloc((strlen(itemPrint->name) + 1) * sizeof(char));
	char* phone = (char*)malloc((strlen(itemPrint->phone) + 1) * sizeof(char));

	//используя копирование строк - заменяем пробелы на подчеркивания (исключаем лишние разделители при чтении)
	ReplaceStr(itemPrint->name, name, ' ', '_');
	ReplaceStr(itemPrint->phone, phone, ' ', '_');

	// пишем данные в файл (сериализация объекта)
	fprintf(pFile, "%s %d %d %s\n", name, itemPrint->age, itemPrint->sex, phone);
	// здесь мы передаем аргументами сами значения, потому что нам не надо получать их обратно.

	free(name);
	free(phone);
}

// функция возвращает целочисленный тип данных - количество прочитанных записей (4 если успешно, -1 если не получилось)
int ScanFileRecord(FILE* pFile, Record* itemScan)
{
	// читаем данные из файла (десериализация объекта)
	int result = fscanf(pFile, "%s %d %d %s\n", itemScan->name, &itemScan->age, &itemScan->sex, itemScan->phone);
	// а здесь мы передаем аргументами указатели на переменные, чтобы изменить их значения внутри вызова функции
	// для name и phone не указывается амперсанд, потому эта переменная УЖЕ указатель

	if (4 == result)
	{
		ReplaceStr(itemScan->name, itemScan->name, '_', ' ');
		ReplaceStr(itemScan->phone, itemScan->phone, '_', ' ');
	}

	return result;
}

void ReplaceStr(const char* source, char* destination, const char oldChar, const char newChar)
{
	//копированием из аргументов в параметры функции, создаются два новых указателя на строки, которые мы можем менять внутри функции

	//копируем символ строки, и смещаем указатели на символ вправо, пока не наткнемся на нулевой символ
	while (0 != *source)
	{
		if (oldChar == *source)
			*destination = newChar;
		else
			*destination = *source;

		source++;
		destination++;
	}

	//заканчиваем копию нулевым байтом
	*destination = 0;

	//или тоже самое одной строкой: лаконично, но невозможно читать.
	//while (*destination++ = (oldChar == *source++) ? newChar : *(source - 1));

	//сейчас указатели source и destionation - указывают на следующий после конца строки символ (за переделами строк), и стали бессмысленными
	//однако параметры указатели(source и destionation) не изменили аргументы указатели (копия не меняет оригинал), которые по прежнему указывают на начало строк
	//при этом общая область памяти на которую указывают аргументы указатели - поменялась в результате работы функции
}
// директивы подключения заголовочных файлов
#include "stdio.h" // поиск файла в текущей директории
#include <malloc.h> // поиск файла в системных директориях
#include <string.h>

// определение структуры
typedef struct
{
    char* name; // указатель(для динамического объекта). Перед использованием, нужно оттдельно выделить память в куче
    int sex; // стековый объект
    int age; // стековый объект
	char phone[15]; // стековый объект для хранения строки длинной до 14 символов + нулевой байт
} Record;

// объявление(declaration) прототипов функций (сигнатура вызова с последовательностью типов параметров)
void PrintRecord(const Record*); // объявление типов параметров
void PrintFileRecord(FILE*, const Record*);
int ScanFileRecord(FILE*, Record*);
void StrReplace(const char* source, char* destination, const char oldChar, const char newChar);

int main () // основная функция, которая вызывается при запуске исполняемого файла (точка входа)
{// начало тела основной функции
    // объявление переменной c типом данных, структура "Record"
    Record item;

    // выделение памяти для массива символов, указателю присваивается адрес начала выделенной области памяти
    item.name = (char*)malloc((strlen("John Blood")+1) * sizeof(char)); 
    // берем длинну строки "John", добавляем 1 (для нулевого байта в конце строки) 
	// и умножаем ее на размер одного символа в памяти
    // получаем указатель на выделенную память типа (void*) и приводим его к строковому типу (char*)

	//проверяем, выделенна ли память? Если нет, то завершаем выполнение программы
	if (item.name == NULL) return -1;
    
    // копирование байтов в выделенный участок памяти
    strcpy(item.name, "John Blood"); // мы передаем в функцию, в качестве аргумента, поле "name" переменной "item"
	strcpy(item.phone, "+7(921)1231234"); // инициализация второй строки

    // инициализация полей переменной(структуры)
    item.sex = 1; // присваиваем значение и тем самым инициализируем поле "sex" переменной "item"
    item.age = 33;
    // необходимо, чтобы все переменные были определены (это именно определение - отличается от объявления тем, что вm этот момент под объект выделяется память)

    FILE* pFile; // объявление переменной, для хранения указателя на файл
    pFile = fopen ("myfile.txt","a"); // открываем файл в режиме записи в конец существующего файла
    
    if (pFile != NULL) // указатель не равен нулю, если файл удалось открыть
    {
        PrintFileRecord(pFile, &item); // вызов функции печати в файл
        fclose(pFile); // закрытие файла
    }

    pFile = fopen ("myfile.txt","r"); // открываем файл в режиме чтения
    if (pFile != NULL) // указатель не равен нулю, если файл удалось открыть
    {
        while (ScanFileRecord(pFile, &item) != EOF) // чтение из файла, пока читается
        {
            // выводим каждую запись на консоль
            PrintRecord(&item);
        }
        fclose(pFile);
    }

    scanf("%s\n"); // ждем ввода, чтобы консоль не закрывалась
	
	free(item.name);// освобождаем выделенную в куче(heap) память

    return 0;
}// завершение тела основной функции


// определение(definition) функции, в отличие от объявления содержит еще и тело функции {...}
void PrintRecord(const Record *itemPrint) // параметр itemPrint - это принятый функцией аргумент (item)
{
    // выводим данные на консоль
	printf("%s %d %d %s\n", itemPrint->name, itemPrint->age, itemPrint->sex, itemPrint->phone);
    // item - указатель на структуру, поэтому в качестве оператора доступа к членам класса(структуры) мы используем "->" (доступ через указатель на структуру/объект)
}

// функция ничего не возвращает, поэтому возврщаемый тип void
void PrintFileRecord(FILE* pFile, const Record* itemPrint)
{
	//выделяем память для модифицированных строк
	char* name = (char*)malloc((strlen(itemPrint->name) + 1) * sizeof(char));
	char* phone = (char*)malloc((strlen(itemPrint->phone) + 1) * sizeof(char));

	//используя копирование строк - заменяем пробелы на подчеркивания (исключаем лишние разделители при чтении)
	StrReplace(itemPrint->name, name, ' ', '_');
	StrReplace(itemPrint->phone, phone, ' ', '_');

    // пишем данные в файл (сериализация объекта)
	fprintf(pFile, "%s %d %d %s\n", name, itemPrint->age, itemPrint->sex, phone);
    // здесь мы передаем аргументами сами значения, потому что нам не надо получать их обратно.

	free(name);
	free(phone);
}

// функция возвращает целочисленный тип данных - количество прочитанных записей (4 если успешно, -1 если не получилось)
int ScanFileRecord(FILE* pFile, Record* itemScan)
{
    // читаем данные из файла (десериализация объекта)
	int result = fscanf(pFile, "%s %d %d %s\n", itemScan->name, &itemScan->age, &itemScan->sex, itemScan->phone);
    // а здесь мы передаем аргументами указатели на переменные, чтобы изменить их значения внутри вызова функции
    // для name и phone не указывается амперсанд, потому эта переменная УЖЕ указатель

	StrReplace(itemScan->name, itemScan->name, '_', ' ');
	StrReplace(itemScan->phone, itemScan->phone, '_', ' ');

	return result;
}

void StrReplace(const char* source, char* destination, const char oldChar, const char newChar)
{
	//копированием из аргументов в параметры функции, создаются два новых указателя на строки, которые мы можем менять внутри функции

	//копируем символ строки, одновременно смещая указатели на символ вправо, пока не наткнемся на нулевой символ
	while (*destination++ = *source++) 
	{
		if (oldChar == *source) //особое копирование с заменой символа
		{
			*destination++ = newChar;
			source++; //смещаем оба указателя, чтобы избежать затирания главным циклом
		}
	}

	//сейчас указатели source и destionation - указывают на следующий после конца строки символ (за переделами строк), и стали бессмысленными
	//однако параметры указатели(source и destionation) не изменили аргументы указатели (копия не меняет оригинал), которые по прежнему указывают на начало строк
	//при этом общая область памяти на которую указывают аргументы указатели - поменялась в результате работы функции
}
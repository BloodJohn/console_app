// директивы подключения заголовочных файлов
#include "stdio.h" // поиск файла в текущей директории
#include <malloc.h> // поиск файла в стандартных директориях
#include <string.h>

// определение структуры
typedef struct
{
    char* name; // указатель(динамический объект). Перед использованием, нужно оттдельно выделить память в куче
    int sex; // стековый объект
    int age; // стековый объект
} Record;

// объявление(declaration) прототипов функций (сигнатура вызова с последовательностью типов параметров)
void PrintRecord(Record*); // объявление типов параметров
void FPrintRecord(FILE*, Record*);
int FScanRecord(FILE*, Record*);

int main () // основная функция, которая вызывается при запуске исполняемого файла (точка входа)
{// начало тела основной функции
    // объявление переменной c типом данных, структура "Record"
    Record item;

    // выделение памяти для массива символов, указателю присваивается адрес начала выделенной области памяти
    item.name = (char*)malloc(strlen("John") * sizeof(char)); 
    // берем длинну строки "John" умножаем ее на размер одного символа в памяти
    //получаем указатель на выделенную память типа (void*) и приводим его к строковому типу (char*)
    
    // копирование байтов в выделенный участок памяти
    strcpy(item.name, "John"); // мы передаем в функцию, в качестве аргумента, поле "name" переменной "item"

    // инициализация полей переменной(структуры)
    item.sex = 1; // присваиваем значение и тем самым инициализируем поле "sex" переменной "item"
    item.age = 33;
    // необходимо, чтобы все переменные были определены (это именно определение - отличается от объявления тем, что вm этот момент под объект выделяется память)

    FILE* pFile; // объявление переменной, для хранения указателя на файл
    pFile = fopen ("myfile.txt","a"); // открываем файл в режиме записи в конец существующего файла
    
    if (pFile != NULL) // указатель не равен нулю, если файл удалось открыть
    {
        FPrintRecord(pFile, &item); // вызов функции печати в файл
        fclose(pFile); // закрытие файла
    }

    pFile = fopen ("myfile.txt","r"); // открываем файл в режиме чтения
    if (pFile != NULL) // указатель не равен нулю, если файл удалось открыть
    {
        while (FScanRecord(pFile, &item) != EOF) // чтение из файла, пока читается
        {
            // выводим каждую запись на консоль
            PrintRecord(&item);
        }
        fclose(pFile);
    }

    free(item.name);// освобождаем выделенную в куче(heap) память

    scanf("%s\n"); // ждем ввода, чтобы консоль не закрывалась

    return 0;
}// завершение тела основной функции


// определение(definition) функции, в отличие от объявления содержит еще и тело функции {...}
void PrintRecord(Record *item) // параметр - это принятый функцией аргумент
{
    // выводим данные на консоль
    printf ("%d %d %s\n",item->age, item->sex, item->name);
    // item - указатель на структуру, поэтому в качестве оператора доступа к членам класса(структуры) мы используем "->" (доступ через указатель на объект)
}

void FPrintRecord(FILE* pFile, Record* item)
{
    // пишем данные в файл (сериализация объекта)
    fprintf (pFile, "%d %d %s\n",item->age, item->sex, item->name);
    // здесь мы передаем аргументами сами значения, потому что нам не надо получать их обратно.
}

// функция возвращает целочисленный тип данных
int FScanRecord(FILE* pFile, Record* item)
{
    // читаем данные из файла (десериализация объекта)
    return fscanf (pFile, "%d %d %s\n", &item->age, &item->sex, item->name);
    // а здесь мы передаем аргументами указатели на переменные, чтобы изменить их значения внутри вызова функции
    // для name не указывается амперсанд, потому эта переменная УЖЕ указатель
}